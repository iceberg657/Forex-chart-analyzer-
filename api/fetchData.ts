
import { GoogleGenAI, Part, Type, Tool } from "@google/genai";
import { 
    AnalysisResult, 
    BotLanguage, 
    IndicatorLanguage, 
    GroundingSource, 
    MarketSentimentResult, 
    TradeEntry,
    JournalFeedback,
    ChatMessage,
    ChatMessagePart,
    PredictedEvent
} from '../types';

// --- UTILITY ---
const robustJsonParse = (jsonString: string, expectedType: 'object' | 'array' = 'object') => {
    let cleanJsonString = jsonString.trim();
    const regex = expectedType === 'object' 
        ? /```(json)?\s*(\{[\s\S]*\})\s*```/ 
        : /```(json)?\s*(\[[\s\S]*\])\s*```/;
    const match = cleanJsonString.match(regex);

    if (match && match[2]) {
        cleanJsonString = match[2];
    } else {
        const startChar = expectedType === 'object' ? '{' : '[';
        const endChar = expectedType === 'object' ? '}' : ']';
        const jsonStart = cleanJsonString.indexOf(startChar);
        const jsonEnd = cleanJsonString.lastIndexOf(endChar);
        if (jsonStart !== -1 && jsonEnd > jsonStart) {
            cleanJsonString = cleanJsonString.substring(jsonStart, jsonEnd + 1);
        }
    }
    try {
        return JSON.parse(cleanJsonString);
    } catch (parseError) {
        console.error("Failed to parse JSON from AI response:", cleanJsonString);
        throw new Error("Failed to process the request. The AI returned an invalid format.");
    }
};


// --- PROMPTS and LOGIC ---

// --- 1. analyzeChart ---
const getAnalysisPrompt = (tradingStyle: string, riskReward: string) => `You are 'Oracle', an apex-level trading AI. Your analysis is institutional-grade, focusing on Smart Money Concepts. You MUST return a single, valid JSON object. Your analysis MUST use web search for real-time context on standard assets. Schema: { "asset": "string", "timeframe": "string", "signal": "'BUY'|'SELL'|'NEUTRAL'", "confidence": "number", "entry": "string", "stopLoss": "string", "takeProfits": ["string"], "setupQuality": "string", "reasoning": "string", "tenReasons": ["string"], "alternativeScenario": "string", "sources": "populated by system"}`;

async function handleAnalyzeChart(body: any) {
    const { imageParts, riskReward, tradingStyle } = body;
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
    const parts: Part[] = [{ text: getAnalysisPrompt(tradingStyle, riskReward) }];
    for (const key of ['higher', 'primary', 'entry']) {
        if (imageParts[key]) {
            parts.push({ text: `${key.charAt(0).toUpperCase() + key.slice(1)} Timeframe Chart:` });
            parts.push({ inlineData: imageParts[key] });
        }
    }
    const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: { parts }, config: { tools: [{googleSearch: {}}] } });
    const parsedResult = robustJsonParse(response.text) as AnalysisResult;
    if (response.candidates?.[0]?.groundingMetadata?.groundingChunks) {
        parsedResult.sources = response.candidates[0].groundingMetadata.groundingChunks.map((c: any) => ({ uri: c.web?.uri || '', title: c.web?.title || 'Source' })).filter((s: any) => s.uri);
    }
    return parsedResult;
}

// --- 2. createBot ---
const getBotPrompt = (description: string, language: BotLanguage) => `You are an expert MQL developer. Generate code for a trading bot (Expert Advisor). Language: ${language}. User Description: "${description}". IMPORTANT: At the top, include these properties: #property copyright "Generated by Grey Algo Apex Trader", #property link "https://greyalgo-trading.netlify.app". Generate complete, functional, well-commented ${language} code. Respond with ONLY the raw code.`;

async function handleCreateBot(body: any) {
    const { description, language } = body;
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });
    const prompt = getBotPrompt(description, language);
    const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
    return response.text;
}

// --- 3. createIndicator ---
const getIndicatorPrompt = (description: string, language: IndicatorLanguage) => { /* ... same as in service ... */ };
async function handleCreateIndicator(body: any) { /* ... similar to handleCreateBot ... */ }

// --- 4. getMarketNews ---
const getMarketSentimentPrompt = (asset: string) => `You are 'Oracle', an apex-level trading AI. Analyze the latest market news and sentiment for **${asset}**. Prioritize reputable financial news sources. You MUST return a single, valid JSON object. Schema: { "asset": "string", "sentiment": "'Bullish'|'Bearish'|'Neutral'", "confidence": "number", "summary": "string", "keyPoints": ["string"], "sources": "populated by system"}`;
async function handleGetMarketNews(body: any) { /* ... similar to handleAnalyzeChart ... */ }

// --- 5. getTradingJournalFeedback ---
const getJournalFeedbackPrompt = (trades: TradeEntry[]) => `You are a 'Trading Performance Coach AI'. Analyze the provided trader's journal and give objective, actionable feedback. You MUST return a single, valid JSON object. Data: ${JSON.stringify(trades, null, 2)}. Schema: { "overallPnl": "number", "winRate": "number", "strengths": ["string"], "weaknesses": ["string"], "suggestions": ["string"]}`;
async function handleGetJournalFeedback(body: any) { /* ... similar to handleAnalyzeChart but with responseMimeType ... */ }

// --- 6. processCommandWithAgent ---
const agentTools: Tool[] = [ { functionDeclarations: [ { name: "navigate", /* ... */ }, { name: "changeTheme", /* ... */ }, { name: "setEdgeLighting", /* ... */ }, { name: "logout" } ] } ];
async function handleProcessCommandWithAgent(body: any) { /* ... */ }

// --- 7. sendMessage (Chat) ---
const CHAT_SYSTEM_INSTRUCTION = `You are the Oracle, a senior institutional quantitative analyst AI...`;
async function handleSendMessage(body: any) { /* ... */ }

// --- 8. getPredictions ---
const getPredictorPrompt = () => `You are 'Oracle', an apex-level trading AI specializing in predicting market impact of economic news. Scan financial calendars and identify the top 3-5 HIGHEST impact events for the next 7 days. You must DECLARE the initial price spike direction (BUY/SELL). You MUST return a single, valid JSON array of objects. Schema: [{ "eventName": "string", "time": "string", "currency": "string", "directionalBias": "'BUY'|'SELL'", "confidence": "number", "rationale": "string", "sources": "populated by system" }]`;
async function handleGetPredictions(body: any) { /* ... similar to handleAnalyzeChart but expecting array ... */ }


// --- MAIN HANDLER ---
export default async function handler(req: any, res: any) {
    if (req.method !== 'POST') {
        return res.status(405).json({ error: "Method Not Allowed" });
    }
    if (!process.env.API_KEY) {
        return res.status(500).json({ error: "API Key not configured." });
    }

    const { action, ...body } = req.body;

    try {
        let result;
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

        switch (action) {
            case 'analyzeChart':
                result = await handleAnalyzeChart(body);
                return res.status(200).json(result);
            
            case 'createBot':
                result = await handleCreateBot(body);
                return res.status(200).send(result);

            case 'createIndicator': {
                const { description, language } = body;
                const prompt = getIndicatorPrompt(description, language);
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
                return res.status(200).send(response.text);
            }

            case 'getMarketNews': {
                 const { asset } = body;
                const prompt = getMarketSentimentPrompt(asset);
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt, config: { tools: [{googleSearch: {}}] } });
                const parsedResult = robustJsonParse(response.text) as MarketSentimentResult;
                if (response.candidates?.[0]?.groundingMetadata?.groundingChunks) {
                    parsedResult.sources = response.candidates[0].groundingMetadata.groundingChunks.map((c: any) => ({ uri: c.web?.uri || '', title: c.web?.title || 'Source' })).filter((s: any) => s.uri);
                }
                return res.status(200).json(parsedResult);
            }

            case 'getTradingJournalFeedback': {
                const { trades } = body;
                const prompt = getJournalFeedbackPrompt(trades);
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt, config: { responseMimeType: 'application/json' } });
                const parsedResult = robustJsonParse(response.text) as JournalFeedback;
                return res.status(200).json(parsedResult);
            }
            
            case 'processCommandWithAgent': {
                const { command } = body;
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: command, config: { tools: agentTools } });
                return res.status(200).json({ text: response.text, functionCalls: response.functionCalls || null });
            }

            case 'sendMessage': {
                const { history, newMessage } = body as { history: ChatMessage[], newMessage: ChatMessagePart[] };
                const contents = history.map(msg => ({ role: msg.role, parts: msg.parts }));
                contents.push({ role: 'user', parts: newMessage });
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents, config: { systemInstruction: CHAT_SYSTEM_INSTRUCTION, tools: [{ googleSearch: {} }] } });
                const modelResponse: ChatMessage = { id: Date.now().toString(), role: 'model', parts: [{ text: response.text }] };
                if (response.candidates?.[0]?.groundingMetadata?.groundingChunks) {
                    modelResponse.sources = response.candidates[0].groundingMetadata.groundingChunks.map((c: any) => ({ uri: c.web?.uri || '', title: c.web?.title || 'Source' })).filter((s: any) => s.uri);
                }
                return res.status(200).json(modelResponse);
            }
            
            case 'getPredictions': {
                const prompt = getPredictorPrompt();
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt, config: { tools: [{googleSearch: {}}] } });
                const parsedResult = robustJsonParse(response.text, 'array') as PredictedEvent[];
                const chunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks;
                if (chunks && Array.isArray(chunks)) {
                    const sources = chunks.map((c: any) => ({ uri: c.web?.uri || '', title: c.web?.title || 'Source' })).filter((s: any) => s.uri);
                    parsedResult.forEach(event => event.sources = sources);
                }
                return res.status(200).json(parsedResult);
            }

            default:
                return res.status(400).json({ error: "Invalid action provided." });
        }
    } catch (error: any) {
        console.error(`Error in /api/fetchData for action "${action}":`, error);
        res.status(500).json({ error: "API request failed", details: error.message });
    }
}
