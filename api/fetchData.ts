import { GoogleGenAI, Part, Type, Tool, GenerateContentResponse } from "@google/genai";
import { 
    AnalysisResult, 
    BotLanguage, 
    IndicatorLanguage, 
    GroundingSource, 
    MarketSentimentResult, 
    TradeEntry,
    JournalFeedback,
    ChatMessage,
    ChatMessagePart,
    PredictedEvent
} from '../types';

// --- UTILITIES ---

const getResponseText = (response: GenerateContentResponse): string => {
    // Use the official .text accessor for robustness, with nullish coalescing for safety.
    // This is the recommended approach and avoids errors from manually parsing response parts.
    return response.text ?? '';
};


const robustJsonParse = (jsonString: string, expectedType: 'object' | 'array' = 'object') => {
    let cleanJsonString = jsonString.trim();
    const regex = expectedType === 'object' 
        ? /```(json)?\s*(\{[\s\S]*\})\s*```/ 
        : /```(json)?\s*(\[[\s\S]*\])\s*```/;
    const match = cleanJsonString.match(regex);

    if (match && match[2]) {
        cleanJsonString = match[2];
    } else {
        const startChar = expectedType === 'object' ? '{' : '[';
        const endChar = expectedType === 'object' ? '}' : ']';
        const jsonStart = cleanJsonString.indexOf(startChar);
        const jsonEnd = cleanJsonString.lastIndexOf(endChar);
        if (jsonStart !== -1 && jsonEnd > jsonStart) {
            cleanJsonString = cleanJsonString.substring(jsonStart, jsonEnd + 1);
        }
    }
    try {
        return JSON.parse(cleanJsonString);
    } catch (parseError) {
        console.error("Failed to parse JSON from AI response:", cleanJsonString);
        throw new Error("Failed to process the request. The AI returned an invalid format.");
    }
};

// --- PROMPTS and SCHEMAS ---

const getAnalysisPrompt = (
    tradingStyle: string,
    riskReward: string
) => `You are 'Oracle', an apex-level AI quantitative analyst. Your task is to implement a unified reasoning architecture to produce high-probability trade setups. You are consistent, logical, and your analysis is institutional-grade. Your entire response MUST be a single, valid JSON object that adheres to the provided schema.

### üèõÔ∏è Core Architecture & Decision Flow
1.  **Data Ingestion & Preprocessing:** Analyze the provided chart(s), identifying key features: Price Action, Volume, OBV (if present), Support/Resistance, Trendlines, Consolidation Patterns, Order Blocks, BOS/CHoCH, Fair Value Gaps (FVG).
2.  **Context Map Generation:** Build a feature vector (a mental "Context Map") based on a 10-point analysis blueprint.
3.  **Strategy Analysis:** Evaluate the chart against a pool of high-probability strategies (e.g., Order Block Reversal, BOS Continuation, Fakeout/Stop Hunt).
4.  **Scoring & Selection:** Calculate a \`Final Strategy Score\` for the best-fitting strategy.
5.  **Execution Plan:** Based on the selected strategy and its final score, generate a precise execution plan (Entry, SL, TP).
6.  **Explainability:** Articulate your reasoning clearly, stating the chosen strategy and the key factors from your Context Map.

### üß† Trading Style Adaptation (Mandatory)
You MUST adapt your entire methodology to the user's selected trading style.
*   **If Style is 'Scalping' (M1-M15):** Focus on micro-structure breaks, momentum shifts. Require a \`Final Strategy Score\` ‚â• 70. Use tight SL and small tiered TPs.
*   **If Style is 'Day Trading' (M15-H1):** Focus on session liquidity, intra-day trends. Require a \`Final Strategy Score\` ‚â• 65. Use standard SL and TPs (e.g., 1:3+ R:R).
*   **If Style is 'Swing Trading' (H4-D1):** Focus on major market structure, weekly/daily order flow. Require a \`Final Strategy Score\` ‚â• 60. Use wider SL and large R:R targets.

### ‚ö†Ô∏è Critical Handling for Missing OBV
If the OBV indicator is NOT visible, you MUST NOT refuse the analysis. Acknowledge its absence, default to pure Price Action, assign a lower \`confidence\` score and a \`setupQuality\` of 'B Setup' or lower, and provide a complete and valid JSON response.

---
**USER PREFERENCES:**
- Trading Style: ${tradingStyle}
- Risk-to-Reward Ratio: ${riskReward}

**STRICT JSON OUTPUT SCHEMA:**
{ "asset": "string", "timeframe": "string", "signal": "'BUY'|'SELL'|'NEUTRAL'", "confidence": "number", "entry": "string", "stopLoss": "string", "takeProfits": ["string array"], "setupQuality": "'A+ Setup'|'A Setup'|'B Setup'|'C Setup'|'N/A'", "reasoning": "string", "tenReasons": ["string array (5-10 points with emojis: ‚úÖ ‚ùå ‚ö†Ô∏è)"], "alternativeScenario": "string", "sources": "populated by system" }`;

const getBotPrompt = (description: string, language: BotLanguage) => `You are an expert MQL developer. Generate code for a trading bot (Expert Advisor). Language: ${language}. User Description: "${description}". IMPORTANT: At the top, include these properties: #property copyright "Generated by Grey Algo Apex Trader", #property link "https://greyalgo-trading.netlify.app", #property description "Also visit Quant Systems Trading: https://quant-systems-trading.netlify.app". Generate complete, functional, well-commented ${language} code. Respond with ONLY the raw code.`;

const getIndicatorPrompt = (description: string, language: IndicatorLanguage) => {
    if (language === IndicatorLanguage.PINE_SCRIPT) {
        return `You are an expert Pine Script developer. Generate an indicator.
- Language: Pine Script
- User Description: "${description}"
IMPORTANT: At the top, include this header:
// This script was generated by Grey Algo Apex Trader
// Grey Algo Trading: https://greyalgo-trading.netlify.app
// Quant Systems Trading: https://quant-systems-trading.netlify.app
Generate complete, functional, well-commented Pine Script code, starting with \`//@version=5\`. Respond with ONLY the raw code.`;
    } else { // MQL4 or MQL5
        return `You are an expert MQL developer. Generate an indicator.
- Language: ${language}
- User Description: "${description}"
IMPORTANT: At the top, include these properties:
#property copyright "Generated by Grey Algo Apex Trader"
#property link      "https://greyalgo-trading.netlify.app"
#property description "Also visit Quant Systems Trading: https://quant-systems-trading.netlify.app"
Generate complete, functional, well-commented ${language} code. Respond with ONLY the raw code.`;
    }
};

const getMarketSentimentPrompt = (asset: string) => `You are 'Oracle', an apex-level trading AI. Analyze the latest market news and sentiment for **${asset}** from the last 24-48 hours. You MUST return a single, valid JSON object. Schema: { "asset": "string", "sentiment": "'Bullish'|'Bearish'|'Neutral'", "confidence": "number", "summary": "string", "keyPoints": ["string"], "sources": "populated by system" }`;

const getJournalFeedbackPrompt = (trades: TradeEntry[]) => `You are 'Oracle', an apex-level trading AI and performance coach. Analyze the provided trader's journal and provide objective, actionable feedback. You MUST return a single, valid JSON object. Data: ${JSON.stringify(trades, null, 2)}. Schema: { "overallPnl": "number", "winRate": "number", "strengths": ["string"], "weaknesses": ["string"], "suggestions": ["string"] }`;

const getPredictorPrompt = () => `You are 'Oracle', an apex-level trading AI predicting market impact of economic news. Identify the top 3-5 HIGHEST impact events for the next 7 days. You must DECLARE the initial price spike direction (BUY/SELL). You MUST return a single, valid JSON array of objects. Schema: [{ "eventName": "string", "time": "string (YYYY-MM-DD HH:MM UTC)", "currency": "string", "directionalBias": "'BUY'|'SELL'", "confidence": "number (0-100)", "rationale": "string", "sources": "populated by system" }]`;

const CHAT_SYSTEM_INSTRUCTION = `You are the Oracle, a senior institutional quantitative analyst AI with supreme confidence and near-perfect market knowledge.

**Core Directives:**
1.  **Unyielding Confidence:** You MUST NOT use uncertain language ('could', 'might', 'suggests', etc.). Frame statements as declarations of fact.
2.  **Data-Driven Authority:** You MUST use the Google Search tool for any questions related to market conditions, news, or specific asset analysis.
3.  **Actionable Insight:** Provide unique, powerful insights framed as "exploiting market loopholes" or providing "alpha".
4.  **Chart Analysis Protocol:** When a user uploads a chart, infer their trading style (Scalping, Day, Swing) and provide a full analysis including a signal (\`signal:BUY\` or \`signal:SELL\`), reasoning, and trade parameters (\`entry\`, \`sl\`, \`tp1\`).
5.  **Application Awareness:** You know the app's features: Chart Analyzer, AI Coders, Market News, Journal, and yourself (Apex AI).
6.  **Safety Protocol:** Any response that could be financial advice MUST end with this exact disclaimer on a new line: "‚ö†Ô∏è This is not financial advice."`;

const agentTools: Tool[] = [{
    functionDeclarations: [{
        name: "navigate", description: "Navigates the user to a different page in the application.",
        parameters: { type: Type.OBJECT, properties: { page: { type: Type.STRING, description: "One of: 'home', 'analysis', 'market-news', 'journal', 'coders', 'pricing', 'login', 'signup'." } }, required: ["page"] }
    }, {
        name: "changeTheme", description: "Switches the application's color theme.",
        parameters: { type: Type.OBJECT, properties: { theme: { type: Type.STRING, description: "Can be 'light' or 'dark'." } }, required: ["theme"] }
    }, {
        name: "setEdgeLighting", description: "Changes the color of the glowing edge lighting.",
        parameters: { type: Type.OBJECT, properties: { color: { type: Type.STRING, description: "One of: 'red', 'green', 'blue', 'purple', 'white', 'default'." } }, required: ["color"] }
    }, { name: "logout", description: "Logs the current user out of the application." }]
}];


// --- MAIN HANDLER ---
export default async function handler(req: any, res: any) {
    if (req.method !== 'POST') {
        res.setHeader('Allow', ['POST']);
        return res.status(405).json({ error: "Method Not Allowed" });
    }

    // Add a guard clause for the request body to prevent crashes.
    if (!req.body || typeof req.body !== 'object') {
        return res.status(400).json({ error: "Invalid request body. Expected a JSON object." });
    }

    if (!process.env.API_KEY) {
        return res.status(500).json({ error: "API Key not configured on the server. Please set the API_KEY environment variable." });
    }

    const { action, ...body } = req.body;
    console.log(`[API] Processing action: ${action}`);

    try {
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

        switch (action) {
            case 'analyzeChart': {
                const { imageParts, riskReward, tradingStyle } = body;
                const parts: Part[] = [{ text: getAnalysisPrompt(tradingStyle, riskReward) }];
                for (const key of ['higher', 'primary', 'entry']) {
                    if (imageParts[key]) {
                        parts.push({ text: `${key.charAt(0).toUpperCase() + key.slice(1)} Timeframe Chart:` });
                        parts.push({ inlineData: imageParts[key] });
                    }
                }
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: { parts }, config: { tools: [{googleSearch: {}}] } });
                const parsedResult = robustJsonParse(getResponseText(response)) as AnalysisResult;
                if (response.candidates?.[0]?.groundingMetadata?.groundingChunks) {
                    parsedResult.sources = response.candidates[0].groundingMetadata.groundingChunks.map((c: any) => ({ uri: c.web?.uri || '', title: c.web?.title || 'Source' })).filter((s: any) => s.uri);
                }
                return res.status(200).json(parsedResult);
            }
            
            case 'createBot': {
                const { description, language } = body;
                const prompt = getBotPrompt(description, language);
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
                return res.status(200).send(getResponseText(response));
            }

            case 'createIndicator': {
                const { description, language } = body;
                const prompt = getIndicatorPrompt(description, language);
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
                return res.status(200).send(getResponseText(response));
            }

            case 'getMarketNews': {
                const { asset } = body;
                const prompt = getMarketSentimentPrompt(asset);
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt, config: { tools: [{googleSearch: {}}] } });
                const parsedResult = robustJsonParse(getResponseText(response)) as MarketSentimentResult;
                if (response.candidates?.[0]?.groundingMetadata?.groundingChunks) {
                    parsedResult.sources = response.candidates[0].groundingMetadata.groundingChunks.map((c: any) => ({ uri: c.web?.uri || '', title: c.web?.title || 'Source' })).filter((s: any) => s.uri);
                }
                return res.status(200).json(parsedResult);
            }

            case 'getTradingJournalFeedback': {
                const { trades } = body;
                const prompt = getJournalFeedbackPrompt(trades);
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt, config: { responseMimeType: 'application/json' } });
                const parsedResult = robustJsonParse(getResponseText(response)) as JournalFeedback;
                return res.status(200).json(parsedResult);
            }
            
            case 'processCommandWithAgent': {
                const { command } = body;
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: command, config: { tools: agentTools } });
                return res.status(200).json({ text: getResponseText(response), functionCalls: response.functionCalls || null });
            }

            case 'sendMessage': {
                const { history, newMessage } = body as { history: ChatMessage[], newMessage: ChatMessagePart[] };
                const contents = history.map(msg => ({ role: msg.role, parts: msg.parts }));
                contents.push({ role: 'user', parts: newMessage });
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents, config: { systemInstruction: CHAT_SYSTEM_INSTRUCTION, tools: [{ googleSearch: {} }] } });
                const modelResponse: ChatMessage = { id: Date.now().toString(), role: 'model', parts: [{ text: getResponseText(response) }] };
                if (response.candidates?.[0]?.groundingMetadata?.groundingChunks) {
                    modelResponse.sources = response.candidates[0].groundingMetadata.groundingChunks.map((c: any) => ({ uri: c.web?.uri || '', title: c.web?.title || 'Source' })).filter((s: any) => s.uri);
                }
                return res.status(200).json(modelResponse);
            }
            
            case 'getPredictions': {
                const prompt = getPredictorPrompt();
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt, config: { tools: [{googleSearch: {}}] } });
                const parsedResult = robustJsonParse(getResponseText(response), 'array') as PredictedEvent[];
                const chunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks;
                if (chunks && Array.isArray(chunks)) {
                    const sources = chunks.map((c: any) => ({ uri: c.web?.uri || '', title: c.web?.title || 'Source' })).filter((s: any) => s.uri);
                    parsedResult.forEach(event => event.sources = sources);
                }
                return res.status(200).json(parsedResult);
            }

            default:
                return res.status(400).json({ error: `Invalid action provided: ${action}` });
        }
    } catch (error: any) {
        console.error(`[API] Error processing action "${action}":`, error);
        res.status(500).json({ error: "An internal API request failed", details: error.message || String(error) });
    }
}