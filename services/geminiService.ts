
import { GoogleGenAI, Part } from "@google/genai";
import { AnalysisResult, BotLanguage, IndicatorLanguage, GroundingSource } from '../types';
import { apiClient } from './apiClient';

// --- UTILITIES ---

const fileToBase64 = (file: File): Promise<{ data: string; mimeType: string }> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      if (typeof reader.result !== 'string') {
        return reject(new Error('FileReader result is not a string'));
      }
      const result = reader.result;
      const data = result.split(',')[1];
      const mimeType = file.type;
      resolve({ data, mimeType });
    };
    reader.onerror = error => reject(error);
  });
};

const robustJsonParse = (jsonString: string) => {
    let cleanJsonString = jsonString.trim();
    const match = cleanJsonString.match(/```(json)?\s*(\{[\s\S]*\})\s*```/);
    if (match && match[2]) {
        cleanJsonString = match[2];
    } else {
        const jsonStart = cleanJsonString.indexOf('{');
        const jsonEnd = cleanJsonString.lastIndexOf('}');
        if (jsonStart !== -1 && jsonEnd > jsonStart) {
            cleanJsonString = cleanJsonString.substring(jsonStart, jsonEnd + 1);
        }
    }
    try {
        return JSON.parse(cleanJsonString);
    } catch (parseError) {
        console.error("Failed to parse JSON from AI response:", cleanJsonString);
        throw new Error("Failed to process the request. The AI returned an invalid format.");
    }
};

// --- PROMPTS ---

const getAnalysisPrompt = (tradingStyle: string, riskReward: string) => `You are 'Oracle', an apex-level trading AI. Your analysis is institutional-grade, focusing on Smart Money Concepts.

**PRIMARY DIRECTIVE:**
Analyze the provided chart(s) and generate a single, valid JSON object.

**ANALYSIS CONTEXT:**
- Synthesize all charts for a top-down analysis.
- You MUST use your web search tool to understand current news and market sentiment for standard assets (FX, stocks, crypto).
- For Synthetic Indices, analysis must be purely technical.
- Prioritize: Market Structure (BOS, CHoCH), Liquidity, Premium/Discount, Order Blocks, FVGs.

**USER PREFERENCES:**
- Trading Style: ${tradingStyle}
- Risk-to-Reward Ratio: ${riskReward}

**STRICT JSON OUTPUT SCHEMA:**
{
  "asset": "string",
  "timeframe": "string (Primary chart's timeframe)",
  "signal": "'BUY', 'SELL', or 'NEUTRAL'",
  "confidence": "number (percentage)",
  "entry": "string (or 'N/A')",
  "stopLoss": "string (or 'N/A')",
  "takeProfits": ["string array (or ['N/A'])"],
  "setupQuality": "string ('A+ Setup', 'A Setup', 'B Setup', 'C Setup', or 'N/A')",
  "reasoning": "string (A 2-4 sentence core thesis)",
  "tenReasons": ["string array (5-10 concise points with emojis: ✅ Bullish, ❌ Bearish, ⚠️ Neutral, 🌐 Web Context)"],
  "alternativeScenario": "string (What invalidates your signal?)",
  "sources": "This will be populated by the system if web search is used."
}`;

const getBotPrompt = (description: string, language: BotLanguage) => `You are an expert MQL developer. Generate code for a trading bot (Expert Advisor).
- Language: ${language}
- User Description: "${description}"
IMPORTANT: At the top, include these properties:
#property copyright "Generated by Grey Algo Apex Trader"
#property link      "https://greyalgo-trading.netlify.app"
#property description "Also visit Quant Systems Trading: https://quant-systems-trading.netlify.app"
Generate complete, functional, well-commented ${language} code. Respond with ONLY the raw code.`;

const getIndicatorPrompt = (description: string, language: IndicatorLanguage) => {
    if (language === IndicatorLanguage.PINE_SCRIPT) {
        return `You are an expert Pine Script developer. Generate an indicator.
- Language: Pine Script
- User Description: "${description}"
IMPORTANT: At the top, include this header:
// This script was generated by Grey Algo Apex Trader
// Grey Algo Trading: https://greyalgo-trading.netlify.app
// Quant Systems Trading: https://quant-systems-trading.netlify.app
Generate complete, functional, well-commented Pine Script code, starting with \`//@version=5\`. Respond with ONLY the raw code.`;
    } else { // MQL4 or MQL5
        return `You are an expert MQL developer. Generate an indicator.
- Language: ${language}
- User Description: "${description}"
IMPORTANT: At the top, include these properties:
#property copyright "Generated by Grey Algo Apex Trader"
#property link      "https://greyalgo-trading.netlify.app"
#property description "Also visit Quant Systems Trading: https://quant-systems-trading.netlify.app"
Generate complete, functional, well-commented ${language} code. Respond with ONLY the raw code.`;
    }
};


// --- SERVICE FUNCTIONS ---

export const analyzeChart = async (
  chartFiles: { [key: string]: File | null },
  riskReward: string,
  tradingStyle: string
): Promise<AnalysisResult> => {
    const imageParts: { [key: string]: { mimeType: string, data: string } | null } = {
        higher: null,
        primary: null,
        entry: null,
    };

    for (const key of Object.keys(chartFiles)) {
        if (chartFiles[key]) {
            imageParts[key] = await fileToBase64(chartFiles[key]!);
        }
    }

    if (process.env.API_KEY) { // Direct call
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
        const parts: Part[] = [{ text: getAnalysisPrompt(tradingStyle, riskReward) }];
        
        const fileTypeMap: { [key: string]: string } = {
            higher: 'Higher Timeframe Chart:',
            primary: 'Primary Timeframe Chart:',
            entry: 'Entry Timeframe Chart:',
        };
        
        for (const key of ['higher', 'primary', 'entry']) {
            if (imageParts[key]) {
                parts.push({ text: fileTypeMap[key] });
                parts.push({ inlineData: imageParts[key]! });
            }
        }
        
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts },
            config: { tools: [{googleSearch: {}}] }
        });

        const parsedResult = robustJsonParse(response.text) as AnalysisResult;

        if (response.candidates?.[0]?.groundingMetadata?.groundingChunks) {
            parsedResult.sources = response.candidates[0].groundingMetadata.groundingChunks
            .map((chunk: any) => ({
                uri: chunk.web?.uri || '',
                title: chunk.web?.title || 'Source',
            }))
            .filter((source: GroundingSource) => source.uri);
        }
        return parsedResult;

    } else { // API endpoint call
        return apiClient.post<AnalysisResult>('analyzeChart', { imageParts, riskReward, tradingStyle });
    }
};

export const createBot = async ({ description, language }: { description: string; language: BotLanguage; }): Promise<string> => {
    if (process.env.API_KEY) {
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
        const prompt = getBotPrompt(description, language);
        const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
        return response.text;
    } else {
        return apiClient.post<string>('createBot', { description, language });
    }
};

export const createIndicator = async ({ description, language }: { description: string; language: IndicatorLanguage; }): Promise<string> => {
    if (process.env.API_KEY) {
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
        const prompt = getIndicatorPrompt(description, language);
        const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
        return response.text;
    } else {
        return apiClient.post<string>('createIndicator', { description, language });
    }
};